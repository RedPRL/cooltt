def path : {
  (A : type) â†’ A â†’ A â†’ type
} = {
  Î» A x y => pathd {Î» _ => A} x y
}

def symm/filler : {
  (A : type) (p : ğ•€ â†’ A) â†’ ğ•€ â†’ ğ•€ â†’ A
}= {
  Î» A p i =>
  hfill A 0 {âˆ‚ i} {Î» j _ =>
    [ j=0 âˆ¨ i=1 => p 0
    | i=0 => p j
    ]
  }
}

def symm : {
  (A : type) (p : ğ•€ â†’ A) â†’ path A {p 1} {p 0}
}= {
  Î» A p i => symm/filler A p i 1
}

def trans/filler : {
  (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) â†’ ğ•€ â†’ ğ•€ â†’ A
} = {
  Î» A p q j i =>
  hcom A 0 j {âˆ‚ i} {Î» j _ =>
    [ j=0 âˆ¨ i=0 => p i
    | i=1 => q j
    ]
  }
}

def trans : {
  (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) â†’ path A {p 0} {q 1}
} = {
  Î» A p q => trans/filler A p q 1
}


def J : {
  (A : type) (p : ğ•€ â†’ A) (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type) â†’
  {C {Î» _ => p 0}} â†’ C p
} = {
  Î» A p C d =>
  coe {Î» i => C {hfill A 0 {âˆ‚ i} {Î» k _ => [k=0 âˆ¨ i=0 => p 0 | i=1 => p k]}}} 0 1 d
}

normalize J

def J/eq : {
  (A : type) (p : ğ•€ â†’ A) (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type) â†’
  (d : C {Î» _ => p 0}) â†’ path {C {Î» _ => p 0}} {J A {Î» _ => p 0} C d} d
} = {
  Î» A p C d =>
  let square : ğ•€ â†’ ğ•€ â†’ A = Î» i => hfill A 0 {âˆ‚ i} {Î» _ _ => p 0} in
  Î» k =>
  let mot : ğ•€ â†’ type =
    Î» i => C {hfill A 0 {âˆ‚ k âˆ¨ âˆ‚ i} {Î» j _ => [k=0 => square i j | j=0 âˆ¨ k=1 âˆ¨ âˆ‚ i => p 0]}}
  in
  com mot 0 1 {âˆ‚ k} {Î» i _ => [k=0 => coe {Î» j => C {square j}} 0 i d | k=1 âˆ¨ i=0 => d]}
}

def trans-left-unit : {
  (A : type) (p : ğ•€ â†’ A)
  â†’ path {path A {p 0} {p 1}} p {trans A {Î» _ => p 0} p}
} = {
  Î» A p k i =>
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {Î» j _ =>
    [ j=0 âˆ¨ i=0 => p 0
    | i=1 => p j
    | k=0 =>
      hcom A 0 1 {âˆ‚ i âˆ¨ âˆ‚ j} {Î» l _ =>
        [ l=0 âˆ¨ j=0 âˆ¨ i=0 => p 0
        | j=1 => trans/filler A {Î» _ => p 0} p i l
        | i=1 => trans/filler A {Î» _ => p 0} p j l
        ]
      }
    ]
  }
}

def trans-right-unit : {
  (A : type) (p : ğ•€ â†’ A)
  â†’ path {path A {p 0} {p 1}} p {trans A p {Î» _ => p 1}}
} = {
  Î» A p => trans/filler A p {Î» _ => p 1}
}

def trans-symm-refl : {
  (A : type) (p : ğ•€ â†’ A)
  â†’ path {path A {p 0} {p 0}} {Î» _ => p 0} {trans A p {symm A p}}
} = {
  Î» A p k i =>
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {Î» j _ =>
    [ j=0 âˆ¨ i=0 => p i
    | k=0 âˆ¨ i=1 => symm/filler A p j i
    ]
  }
}

def cong : {
  (A : type) (B : type) (f : A â†’ B) (p : ğ•€ â†’ A) â†’
  path B {f {p 0}} {f {p 1}}
} = {
  Î» A B f p i => f {p i}
}

def + : nat â†’ nat â†’ nat = {
  Î» elim [
  | zero => Î» n => n
  | suc {_ => ih} => Î» n => suc {ih n}
  ]
}

def +-right-unit : (x : nat) â†’ path nat {+ x 0} x = {
  Î» elim [
  | zero =>
    Î» _ => 0
  | suc {y => ih} =>
    Î» i => suc {ih i}
  ]
}

def +-left-unit : (x : nat) â†’ path nat {+ 0 x} x = {
  Î» x _ => x
}

def +-suc-r : (x : nat) (y : nat) â†’ path nat {+ x {suc y}} {suc {+ x y}} = {
  Î» elim [
  | zero =>
    Î» x i => {suc x}
  | suc {x => ih} =>
    Î» y i => suc {ih y i}
  ]
}

def +-comm : (x : nat) (y : nat) â†’ path nat {+ y x} {+ x y} = {
  Î» elim [
  | zero => +-right-unit
  | suc {y => ih} =>
    Î» z =>
    trans nat {+-suc-r z y} {Î» j => suc {ih z j}}
  ]
}

def +-assoc : {
  (x : nat) (y : nat) (z : nat) â†’
  path nat {+ {+ x y} z} {+ x {+ y z}}
} = {
  Î» elim [
  | zero => Î» y z i => + y z
  | suc {x => ih} => Î» y z i => suc {ih y z i}
  ]
}

def test : {
  (p : ğ•€ â†’ nat) â†’ (i : ğ•€) â†’ nat
} = {
  Î» p i =>
  rec {symm nat p i} @ nat [
  | zero => zero
  | suc {x => ih} => zero
  ]
}


def test2 : {
  (i : ğ•€) â†’ nat
} = {
  Î» i =>
  rec {symm nat {\_ => zero} i} @ nat [
  | zero => zero
  | suc {x => ih} => zero
  ]
}

normalize test

-- You can "normalize" test2; observe how on the inside, there is some eliminator
-- that ought to be computed away, but is blocked by a disjunction system.
normalize test2

-- The following illustrates that although cooltt's quasi-normal forms aren't as fully
-- reduced as they could be, it is of no consequence for definitional
-- equivalence. That is, we don't bother pushing eliminators through all the
-- branches of a disjunction split, but our equational theory acts as if we do.
def test2' : sub {ğ•€ â†’ nat} #t {Î» i => hcom nat 0 1 {âˆ‚ i} {Î» _ _ => 0}} = test2

