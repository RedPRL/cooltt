def path (A : type) (x : A) (y : A) : type =
  pathd {_ => A} x y

def symm/filler (A : type) (p : ğ•€ â†’ A) (i : ğ•€) : ğ•€ â†’ A =
  hfill A 0 {âˆ‚ i} {j _ =>
    [ j=0 âˆ¨ i=1 => p 0
    | i=0 => p j
    ]
  }

def symm (A : type) (p : ğ•€ â†’ A) : path A {p 1} {p 0} =
  i => symm/filler A p i 1

def trans/filler (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) (j : ğ•€) (i : ğ•€) : A =
  hcom A 0 j {âˆ‚ i} {j _ =>
    [ j=0 âˆ¨ i=0 => p i
    | i=1 => q j
    ]
  }

def trans (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) : path A {p 0} {q 1} =
  trans/filler A p q 1


def J (A : type) (p : ğ•€ â†’ A) (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type) (d : C {_ => p 0}) : C p =
  coe {i =>
    C {hfill A 0 {âˆ‚ i} {k _ => [k=0 âˆ¨ i=0 => p 0 | i=1 => p k]}}
  } 0 1 d

normalize J

def J/eq
  (A : type)
  (p : ğ•€ â†’ A)
  (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type)
  (d : C {_ => p 0})
  : path {C {_ => p 0}} {J A {_ => p 0} C d} d
  =
  let square : ğ•€ â†’ ğ•€ â†’ A = i => hfill A 0 {âˆ‚ i} {_ _ => p 0} in
  k =>
  let mot : ğ•€ â†’ type =
    i => C {hfill A 0 {âˆ‚ k âˆ¨ âˆ‚ i} {j _ => [k=0 => square i j | j=0 âˆ¨ k=1 âˆ¨ âˆ‚ i => p 0]}}
  in
  com mot 0 1 {âˆ‚ k} {i _ => [k=0 => coe {j => C {square j}} 0 i d | k=1 âˆ¨ i=0 => d]}

def trans-left-unit (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 1}} p {trans A {_ => p 0} p} =
  k i =>
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {j _ =>
    [ j=0 âˆ¨ i=0 => p 0
    | i=1 => p j
    | k=0 =>
      hcom A 0 1 {âˆ‚ i âˆ¨ âˆ‚ j} {l _ =>
        let filler : ğ•€ â†’ A = k => trans/filler A {_ => p 0} p k l in
        [ l=0 âˆ¨ i=0 âˆ¨ j=1 => filler i
        | i=1 âˆ¨ j=0 => filler j
        ]
      }
    ]
  }

def trans-right-unit (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 1}} p {trans A p {_ => p 1}} =
  trans/filler A p {_ => p 1}


def trans-symm-refl (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 0}} {_ => p 0} {trans A p {symm A p}} =
  k i =>
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {j _ =>
    symm/filler A p j i
  }

normalize trans-left-unit
normalize trans-right-unit
normalize trans-symm-refl

def + : nat â†’ nat â†’ nat =
  elim [
  | zero => n => n
  | suc {_ => ih} => n => suc {ih n}
  ]

def +-right-unit : (x : nat) â†’ path nat {+ x 0} x =
  elim [
  | zero =>
    _ => 0
  | suc {y => ih} =>
    i => suc {ih i}
  ]

def +-left-unit (x : nat) : path nat {+ 0 x} x =
  _ => x

def +-suc-r : (x : nat) (y : nat) â†’ path nat {+ x {suc y}} {suc {+ x y}} =
  elim [
  | zero =>
    x i => {suc x}
  | suc {x => ih} =>
    y i => suc {ih y i}
  ]

def +-comm : (x : nat) (y : nat) â†’ path nat {+ y x} {+ x y} =
  elim [
  | zero => +-right-unit
  | suc {y => ih} =>
    z =>
    trans nat {+-suc-r z y} {j => suc {ih z j}}
  ]

def +-assoc : (x : nat) (y : nat) (z : nat) â†’ path nat {+ {+ x y} z} {+ x {+ y z}} =
  elim [
  | zero => y z i => + y z
  | suc {x => ih} => y z i => suc {ih y z i}
  ]


def test (p : ğ•€ â†’ nat) : (i : ğ•€) â†’ nat =
  let fun : nat â†’ nat =
    elim [
    | zero => zero
    | suc _ => zero
    ]
  in
  i => fun {symm nat p i}


def test2 : (i : ğ•€) â†’ nat =
  let fun : nat â†’ nat =
    elim [
    | zero => zero
    | suc _ => zero
    ]
  in
  i =>
  fun {symm nat {_ => zero} i}

normalize test

-- You can "normalize" test2
normalize test2

-- The following illustrates that although cooltt's quasi-normal forms aren't as fully
-- reduced as they could be, it is of no consequence for definitional
-- equivalence. That is, we don't bother pushing eliminators through all the
-- branches of a disjunction split, but our equational theory acts as if we do.
def test2' : sub {ğ•€ â†’ nat} #t {i => hcom nat 0 1 {âˆ‚ i} {_ _ => 0}} = test2
