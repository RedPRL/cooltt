import prelude
import nat

def evan-test (A : type) (Ï† : ğ”½) (a : A)
  (p : sub {path A a a} Ï† {_ => a})
  : (j : ğ•€) â†’ A
  :=
  p

abstract
def J (A : type) (p : ğ•€ â†’ A) (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type) (d : C {_ => p 0}) : C p :=
  coe {i =>
    C {hfill A 0 {âˆ‚ i} {k => [k=0 âˆ¨ i=0 => p 0 | i=1 => p k]}}
  } 0 1 d

unfold J
#normalize J

abstract
def J/eq (A : type) (p : ğ•€ â†’ A) (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type) (d : C {_ => p 0}) : path {C {_ => p 0}} {J A {_ => p 0} C d} d :=
  let square : ğ•€ â†’ ğ•€ â†’ A := i => hfill A 0 {âˆ‚ i} {_ => p 0} in
  k =>
  let mot : ğ•€ â†’ type :=
    i => C {hfill A 0 {âˆ‚ k âˆ¨ âˆ‚ i} {j => [k=0 => square i j | j=0 âˆ¨ k=1 âˆ¨ âˆ‚ i => p 0]}}
  in
  unfold J in
  com mot 0 1 {âˆ‚ k} {i => [k=0 => coe {j => C {square j}} 0 i d | k=1 âˆ¨ i=0 => d]}

abstract
def trans-left-unit (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 1}} p {trans A {_ => p 0} p} :=
  k i =>
  unfold trans in
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {j =>
    [ j=0 âˆ¨ i=0 => p 0
    | i=1 => p j
    | k=0 =>
      hcom A 0 1 {âˆ‚ i âˆ¨ âˆ‚ j} {l =>
        let filler : ğ•€ â†’ A := k => trans/filler A {_ => p 0} p k l in
        [ l=0 âˆ¨ i=0 âˆ¨ j=1 => filler i
        | i=1 âˆ¨ j=0 => filler j
        ]
      }
    ]
  }

def trans-right-unit (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 1}} p {trans A p {_ => p 1}} :=
  unfold trans in
  trans/filler A p {_ => p 1}


def trans-symm-refl (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 0}} {_ => p 0} {trans A p {symm A p}} :=
  k i =>
  unfold trans symm in
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {j =>
    symm/filler A p j i
  }

#normalize +-assoc

unfold +-assoc +-left-unit +-suc-l +
#normalize +-assoc

#normalize trans-left-unit
#normalize trans-right-unit
#normalize trans-symm-refl

def test (p : ğ•€ â†’ nat) : (i : ğ•€) â†’ nat :=
  let fun : nat â†’ nat :=
    elim [
    | zero => zero
    | suc _ => zero
    ]
  in
  i => fun {symm nat p i}


def test2 : (i : ğ•€) â†’ nat :=
  let fun : nat â†’ nat :=
    elim [
    | zero => zero
    | suc _ => zero
    ]
  in
  i =>
  fun {symm nat {_ => zero} i}

#normalize test

#normalize test2

-- The following illustrates that although cooltt's quasi-normal forms aren't as fully
-- reduced as they could be, it is of no consequence for definitional
-- equivalence. That is, we don't bother pushing eliminators through all the
-- branches of a disjunction split, but our equational theory acts as if we do.
def test2' : sub {ğ•€ â†’ nat} âŠ¤ {i => hcom nat 0 1 {âˆ‚ i} {_ => 0}} := unfold symm in test2
