def path (A : type) (x : A) (y : A) : type =
  pathd {_ â‡’ A} x y

def symm/filler (A : type) (p : ğ•€ â†’ A) (i : ğ•€) : ğ•€ â†’ A =
  hfill A 0 {âˆ‚ i} {j _ â‡’
    [ j=0 âˆ¨ i=1 â‡’ p 0
    | i=0 â‡’ p j
    ]
  }

def symm (A : type) (p : ğ•€ â†’ A) : path A {p 1} {p 0} =
  i â‡’ symm/filler A p i 1

def trans/filler (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) (j : ğ•€) (i : ğ•€) : A =
  hcom A 0 j {âˆ‚ i} {j _ â‡’
    [ j=0 âˆ¨ i=0 â‡’ p i
    | i=1 â‡’ q j
    ]
  }

def trans (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) : path A {p 0} {q 1} =
  trans/filler A p q 1


def J (A : type) (p : ğ•€ â†’ A) (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type) (d : C {_ â‡’ p 0}) : C p =
  coe {i â‡’
    C {hfill A 0 {âˆ‚ i} {k _ â‡’ [k=0 âˆ¨ i=0 â‡’ p 0 | i=1 â‡’ p k]}}
  } 0 1 d

normalize J

def J/eq
  (A : type)
  (p : ğ•€ â†’ A)
  (C : {(i : ğ•€) â†’ sub A {i=0} {p 0}} â†’ type)
  (d : C {_ â‡’ p 0})
  : path {C {_ â‡’ p 0}} {J A {_ â‡’ p 0} C d} d
  =
  let square : ğ•€ â†’ ğ•€ â†’ A = i â‡’ hfill A 0 {âˆ‚ i} {_ _ â‡’ p 0} in
  k â‡’
  let mot : ğ•€ â†’ type =
    i â‡’ C {hfill A 0 {âˆ‚ k âˆ¨ âˆ‚ i} {j _ â‡’ [k=0 â‡’ square i j | j=0 âˆ¨ k=1 âˆ¨ âˆ‚ i â‡’ p 0]}}
  in
  com mot 0 1 {âˆ‚ k} {i _ â‡’ [k=0 â‡’ coe {j â‡’ C {square j}} 0 i d | k=1 âˆ¨ i=0 â‡’ d]}

def trans-left-unit (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 1}} p {trans A {_ â‡’ p 0} p} =
  k i â‡’
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {j _ â‡’
    [ j=0 âˆ¨ i=0 â‡’ p 0
    | i=1 â‡’ p j
    | k=0 â‡’
      hcom A 0 1 {âˆ‚ i âˆ¨ âˆ‚ j} {l _ â‡’
        let filler : ğ•€ â†’ A = k â‡’ trans/filler A {_ â‡’ p 0} p k l in
        [ l=0 âˆ¨ i=0 âˆ¨ j=1 â‡’ filler i
        | i=1 âˆ¨ j=0 â‡’ filler j
        ]
      }
    ]
  }

def trans-right-unit (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 1}} p {trans A p {_ â‡’ p 1}} =
  trans/filler A p {_ â‡’ p 1}


def trans-symm-refl (A : type) (p : ğ•€ â†’ A) : path {path A {p 0} {p 0}} {_ â‡’ p 0} {trans A p {symm A p}} =
  k i â‡’
  hcom A 0 1 {k=0 âˆ¨ âˆ‚ i} {j _ â‡’
    symm/filler A p j i
  }

normalize trans-left-unit
normalize trans-right-unit
normalize trans-symm-refl

def + : nat â†’ nat â†’ nat =
  elim [
  | zero â‡’ n â‡’ n
  | suc {_ â‡’ ih} â‡’ n â‡’ suc {ih n}
  ]

def +-right-unit : (x : nat) â†’ path nat {+ x 0} x =
  elim [
  | zero â‡’
    _ â‡’ 0
  | suc {y â‡’ ih} â‡’
    i â‡’ suc {ih i}
  ]

def +-left-unit (x : nat) : path nat {+ 0 x} x =
  _ â‡’ x

def +-suc-r : (x : nat) (y : nat) â†’ path nat {+ x {suc y}} {suc {+ x y}} =
  elim [
  | zero â‡’
    x i â‡’ {suc x}
  | suc {x â‡’ ih} â‡’
    y i â‡’ suc {ih y i}
  ]

def +-comm : (x : nat) (y : nat) â†’ path nat {+ y x} {+ x y} =
  elim [
  | zero â‡’ +-right-unit
  | suc {y â‡’ ih} â‡’
    z â‡’
    trans nat {+-suc-r z y} {j â‡’ suc {ih z j}}
  ]

def +-assoc : (x : nat) (y : nat) (z : nat) â†’ path nat {+ {+ x y} z} {+ x {+ y z}} =
  elim [
  | zero â‡’ y z i â‡’ + y z
  | suc {x â‡’ ih} â‡’ y z i â‡’ suc {ih y z i}
  ]


def test (p : ğ•€ â†’ nat) : (i : ğ•€) â†’ nat =
  let fun : nat â†’ nat =
    elim [
    | zero â‡’ zero
    | suc _ â‡’ zero
    ]
  in
  i â‡’ fun {symm nat p i}


def test2 : (i : ğ•€) â†’ nat =
  let fun : nat â†’ nat =
    elim [
    | zero â‡’ zero
    | suc _ â‡’ zero
    ]
  in
  i â‡’
  fun {symm nat {_ â‡’ zero} i}

normalize test

-- You can "normalize" test2; observe how on the inside, there is some eliminator
-- that ought to be computed away, but is blocked by a disjunction system.
normalize test2

-- The following illustrates that although cooltt's quasi-normal forms aren't as fully
-- reduced as they could be, it is of no consequence for definitional
-- equivalence. That is, we don't bother pushing eliminators through all the
-- branches of a disjunction split, but our equational theory acts as if we do.
def test2' : sub {ğ•€ â†’ nat} #t {i â‡’ hcom nat 0 1 {âˆ‚ i} {_ _ â‡’ 0}} = test2
