def boundary-test : (i : ð•€) (_ : [âˆ‚ i]) â†’ nat = {
  \i _ =>
   [ i=1 => 5
   | i=0 => 19
   ]
}

normalize boundary-test

def reflexivity : (A : univ) (a : A) (i : ð•€) â†’ A = {
  \A a _ => a
}

def foo : (x : nat) â†’ (y : nat) Ã— Id nat x y = {
  \x =>
  [x, ?hole1]
}

def sym : (A : univ) (x : A) (y : A) (p : Id A x y) â†’ Id A y x = {
  \A x y p =>
  elim p @ {u v _ => Id A v u} [
  | refl => refl
  ]
}

def trans : {
  (A : univ) (x : A) (y : A) (z : A)
  (p : Id A x y) (q : Id A y z)
  â†’ Id A x z
} = {
  \A x y z p =>
  elim p @ {u v _ => (q : Id A v z) â†’ Id A u z} [
  | refl => \q => q
  ]
}

normalize sym
normalize trans

def hole-in-type : {
  (x : nat) (y : nat) (z : nat)
  (p : Id nat x y) (q : Id nat y z)
  â†’ ?tyhole
} = {
  \y z => ?tmhole
}


def pi-code-test : univ = (x : nat) â†’ nat

def foo : pi-code-test =
  \x => x

normalize pi-code-test
