def boundary-test : (i : ð•€) (_ : [âˆ‚ i]) â†’ nat = {
  \i _ =>
   [ i=1 => 5
   | i=0 => 19
   ]
}

normalize boundary-test

def reflexivity : (A : univ) (a : A) (i : ð•€) â†’ A = {
  \A a _ => a
}


def pi-code-test : univ = (x : nat) â†’ nat

def foo : pi-code-test =
  \x => x

normalize pi-code-test


def simple-let : {
  (A : univ) (a : A) -> A
} = {
  \A a =>
  let b : A = a in
  b
}

normalize simple-let


def hole-in-type : {
  (x : nat) (y : nat) (z : nat)
  â†’ ?tyhole
} = {
  \y z => ?tmhole
}

def foo : (x : nat) â†’ (y : nat) Ã— path {\i => nat} x y = {
  \x =>
  [x, ?hole1]
}
