def extensional-cofibrations : (phi : cof) (i : dim) (_ : [phi]) (_ : [{i==0} \/ {0==1}]) -> [0==i] = {
  \phi i _ α => α
}

def foo : (phi : cof) (psi : cof) (_ : [phi \/ psi]) -> nat = {
  \phi psi _ => 
    [ phi => 5
    | psi => ?
    ]
}

normalize foo

quit

def reflexivity : (A : univ) (a : A) (i : dim) -> A = {
  \A a _ => a
}

def foo : (x : nat) -> (y : nat) * Id nat x y = {
  \x =>
  [x, ?hole1]
}

def sym : (A : univ) (x : A) (y : A) (p : Id A x y) -> Id A y x = {
  \A x y p =>
  elim p @ {u v _ => Id A v u} [
  | refl => refl
  ]
}

def trans : {
  (A : univ) (x : A) (y : A) (z : A)
  (p : Id A x y) (q : Id A y z)
  -> Id A x z
} = {
  \A x y z p =>
  elim p @ {u v _ => (q : Id A v z) -> Id A u z} [
  | refl => \q => q
  ]
}

normalize sym
normalize trans

def hole-in-type : {
  (x : nat) (y : nat) (z : nat)
  (p : Id nat x y) (q : Id nat y z)
  -> ?tyhole
} = {
  \y z => ?tmhole
}


def pi-code-test : univ = (x : nat) -> nat
def id-code-test : univ = (x : nat) * Id nat x x

normalize pi-code-test
normalize id-code-test
