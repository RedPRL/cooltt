
def hom (A : type) (a b : A) : type :=
  (i : ğŸš) â†’ fsub A with [i = d0 â‡’ a | i = d1 â‡’ b]

def homO (A : (i : ğŸš) â†’ type) (a : A d0) (b : A d1) : type :=
  (i : ğŸš) â†’ fsub A i with [i = d0 â‡’ a | i = d1 â‡’ b]

def cofTest (A : type) (a : A) : type :=
  (Î± : cof) â†’ fsub A with [Î± â‡’ a]

def crazyTest (A : type) (a b : A) : type :=
  (i j : ğŸš) â†’ {fsub A with [i = d0 â‡’ a | i = d1 â‡’ b]
              Ã— {(k : ğŸš) â†’ fsub A with [i = d0 â‡’ a | k = d1 â‡’ a]}}
            â†’ (Î± : cof) â†’ fsub A with [i = d0 â‡’ a | j = d1 â‡’ a | Î± â‡’ a]

def partTest (A : type) (a b : A) : type :=
  (i j : ğŸš) â†’ <{i=j}> â†’ fsub A with [ i=d0 â‡’ a | j=d1 â‡’ b ]

def partTermTest (A : type) (a b : A) (p : hom A a b) : partTest A a b :=
  i j â‡’ p j




def triangle : type := (i j : ğŸš) â†’ <{i â‰¤ j}> â†’ type
def horn (A : triangle) : type := (i j : ğŸš) â†’ <{i=d0 âˆ¨ j=d1}> â†’ A i j

def isInner (A : (i j : ğŸš) â†’ <{i â‰¤ j}> â†’ type) : type :=
  (Î± : cof) â†’
  (b : horn A) â†’
  (t : (i j : ğŸš) â†’ <{i â‰¤ j âˆ§ Î±}>
     â†’ fsub A i j with [i=d0 âˆ¨ j=d1 â‡’ b i j]) â†’
  (i j : ğŸš) â†’ <{i â‰¤ j}> â†’
  fsub A i j with [ Î±           â‡’ t i j
                  | i=d0 âˆ¨ j=d1 â‡’ b i j ]

def relInner (Î“ : type) (A : Î“ â†’ type) : type :=
    (p : (i j : ğŸš) â†’ <{i â‰¤ j}> â†’  Î“)
    â†’ isInner {i j â‡’ {A {p i j}}}


/-
def isCovTy : type :=
  (i j : ğŸš) â†’ <{i â‰¤ j}> â†’ (A : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’ type) â†’ type

-- Should we be able to denote i and j as fancy/modal?

def isCov : isCovTy :=
  i j A â‡’
  (Î± : cof) â†’
  (b : A i) â†’
  (t : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j âˆ§ Î±}>
     â†’ fsub A k with [i=k â‡’ b]) â†’
  (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’
  fsub A k with [ Î±   â‡’ t k
                | i=k â‡’ b ]
-/

 -- (i j : ğŸš) â†’ <{i â‰¤ j}> â†’ (p : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’  Î“) â†’ isCov i j (A o p)
def relCov (Î“ : type) (A : Î“ â†’ type) : type :=
    (i j : ğŸš) â†’ <{i â‰¤ j}> â†’
    (p : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’  Î“) â†’
    (Î± : cof) â†’
    (b : A {p i}) â†’
    (t : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j âˆ§ Î±}>
       â†’ fsub A {p k} with [i=k â‡’ b]) â†’
    (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’
    fsub A {p k} with [ Î±   â‡’ t k
                      | i=k â‡’ b ]


def prodInner (Î“ : type) (A : Î“ â†’ type) (B : Î“ â†’ type)
              (inA : relInner Î“ A) (inB : relInner Î“ B)
              : relInner Î“ {Î³ â‡’ A Î³ Ã— B Î³} :=
    p Î± b t i j â‡’ [ inA p Î± {i j â‡’ fst {b i j}} {i j â‡’ fst {t i j}} i j
                  , inB p Î± {i j â‡’ snd {b i j}} {i j â‡’ snd {t i j}} i j ]

def prodCov (Î“ : type) (A : Î“ â†’ type) (B : Î“ â†’ type)
            (covA : relCov Î“ A) (covB : relCov Î“ B)
            : relCov Î“ {Î³ â‡’ A Î³ Ã— B Î³} :=
    i j p Î± b t k â‡’ [ covA i j p Î± {fst b} {k â‡’ fst {t k}} k
                    , covB i j p Î± {snd b} {k â‡’ snd {t k}} k ]


def sigmaInner (Î“ : type) (A : Î“ â†’ type) (B : (Î³ : Î“) â†’ A Î³ â†’ type)
               (inA : relInner Î“ A) (inB : relInner {(Î³ : Î“) Ã— A Î³} {p â‡’ B {fst p} {snd p}})
               : relInner Î“ {Î³ â‡’ (a : A Î³) Ã— B Î³ a} :=
    p Î± b t i j â‡’
        let a : (i j : ddim) â†’ <{i â‰¤ j}> â†’ A {p i j} :=
            inA p Î± {i j â‡’ fst {b i j}} {i j â‡’ fst {t i j}} in
        [ a i j
        , inB {i j â‡’ [p i j , a i j ]} Î± {i j â‡’ snd {b i j}} {i j â‡’ snd {t i j}} i j ]

def sigmaCov (Î“ : type) (A : Î“ â†’ type) (B : (Î³ : Î“) â†’ A Î³ â†’ type)
             (covA : relCov Î“ A) (covB : relCov {(Î³ : Î“) Ã— A Î³} {p â‡’ B {fst p} {snd p}})
             : relCov Î“ {Î³ â‡’ (a : A Î³) Ã— B Î³ a} :=
    i j p Î± b t k â‡’
        let a : (k : ğŸš) â†’ [i â‰¤ k âˆ§ k â‰¤ j] â†’ A {p k} :=
            covA i j p Î± {fst b} {k â‡’ fst {t k}} in
        [ a k
        , covB i j {k â‡’ [p k , a k]} Î± {snd b} {k â‡’ snd {t k}} k ]


/-
   TODO: fix surface syntax to match cof proof terms
         fix refiner to work in type signatures
         fix bug in semantics of Î£-types stopping sigmaInner/sigmaCov
-/

-- Make sure that we can't do anything weird with domain variables...
#fail def domScope (A : type) (a b : type) : type :=
  (i : ğ•€) Ã— fsub A with [ i = 0 => a | i = 1 => b ]

def path (A : type) (x y : A) : type :=
  (i : ğ•€) â†’ fsub A with [i=0 => x | i=1 => y]

-- Make sure that variables bound by 'coe' are not marked as domain variables!
#fail def evilCode (x y : nat) : path nat x y :=
  i => coe {j => {fsub nat with [ j=0 => x | j=1 => y ]}} 0 i x
