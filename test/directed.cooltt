
def hom (A : type) (a b : A) : type :=
  (i : ğŸš) â†’ fsub A with [i = d0 â‡’ a | i = d1 â‡’ b]

def homO (A : (i : ğŸš) â†’ type) (a : A d0) (b : A d1) : type :=
  (i : ğŸš) â†’ fsub A i with [i = d0 â‡’ a | i = d1 â‡’ b]

def cofTest (A : type) (a : A) : type :=
  (Î± : cof) â†’ fsub A with [Î± â‡’ a]

def crazyTest (A : type) (a b : A) : type :=
  (i j : ğŸš) â†’ {fsub A with [i = d0 â‡’ a | i = d1 â‡’ b]
              Ã— {(k : ğŸš) â†’ fsub A with [i = d0 â‡’ a | k = d1 â‡’ a]}}
            â†’ (Î± : cof) â†’ fsub A with [i = d0 â‡’ a | j = d1 â‡’ a | Î± â‡’ a]

def partTest (A : type) (a b : A) : type :=
  (i j : ğŸš) â†’ <{i=j}> â†’ fsub A with [ i=d0 â‡’ a | j=d1 â‡’ b ]

def partTermTest (A : type) (a b : A) (p : hom A a b) : partTest A a b :=
  i j â‡’ p j



def triangle : type := (i j : ğŸš) â†’ <{i â‰¤ j}> â†’ type
def horn (A : triangle) : type := (i j : ğŸš) â†’ <{i=d0 âˆ¨ j=d1}> â†’ A i j

def isInner (A : triangle) : type :=
  (Î± : cof) â†’
  (b : horn A) â†’
  (t : (i j : ğŸš) â†’ <{i â‰¤ j âˆ§ Î±}>
     â†’ fsub A i j with [i=d0 âˆ¨ j=d1 â‡’ b i j]) â†’
  (i j : ğŸš) â†’ <{i â‰¤ j}> â†’
  fsub A i j with [ Î±           â‡’ t i j
                  | i=d0 âˆ¨ j=d1 â‡’ b i j ]

def relInner (Î“ : type) (A : Î“ â†’ type) : type :=
    (p : (i j : ğŸš) â†’ <{i â‰¤ j}> â†’  Î“)
    â†’ isInner {i j â‡’ {A {p i j}}}

/-
def isCovTy : type :=
  (i j : ğŸš) â†’ <{i â‰¤ j}> â†’ (A : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’ type) â†’ type

-- Should we be able to denote i and j as fancy/modal?

def isCov : isCovTy :=
  i j A â‡’
  (Î± : cof) â†’
  (b : A i) â†’
  (t : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j âˆ§ Î±}>
     â†’ fsub A k with [i=k â‡’ b]) â†’
  (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’
  fsub A k with [ Î±   â‡’ t k
                | i=k â‡’ b ]
-/

 -- (i j : ğŸš) â†’ <{i â‰¤ j}> â†’ (p : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’  Î“) â†’ isCov i j (A o p)
def relCov (Î“ : type) (A : Î“ â†’ type) : type :=
    (i j : ğŸš) â†’ <{i â‰¤ j}> â†’
    (p : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’  Î“) â†’
    (Î± : cof) â†’
    (b : A {p i}) â†’
    (t : (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j âˆ§ Î±}>
       â†’ fsub A {p k} with [i=k â‡’ b]) â†’
    (k : ğŸš) â†’ <{i â‰¤ k âˆ§ k â‰¤ j}> â†’
    fsub A {p k} with [ Î±   â‡’ t k
                      | i=k â‡’ b ]

def prodInner (Î“ : type) (A : Î“ â†’ type) (B : Î“ â†’ type)
              (inA : relInner Î“ A) (inB : relInner Î“ B)
              : relInner Î“ {Î³ â‡’ A Î³ Ã— B Î³} :=
    p Î± b t i j â‡’ [ inA p Î± {i j â‡’ fst {b i j}} {i j â‡’ fst {t i j}} i j
                  , inB p Î± {i j â‡’ snd {b i j}} {i j â‡’ snd {t i j}} i j ]

def prodCov (Î“ : type) (A : Î“ â†’ type) (B : Î“ â†’ type)
            (covA : relCov Î“ A) (covB : relCov Î“ B)
            : relCov Î“ {Î³ â‡’ A Î³ Ã— B Î³} :=
    i j p Î± b t k â‡’ [ covA i j p Î± {fst b} {k â‡’ fst {t k}} k
                    , covB i j p Î± {snd b} {k â‡’ snd {t k}} k ]

/-
def sigmaInner (Î“ : type) (A : Î“ â†’ type) (B : (Î³ : Î“) â†’ A Î³ â†’ type)
               (inA : relInner Î“ A) (inB : relInner {(Î³ : Î“) Ã— A Î³} {p â‡’ B {fst p} {snd p}})
               : relInner Î“ {Î³ â‡’ (a : A Î³) Ã— B Î³ a} :=
    p Î± b t i j â‡’
        let a : (i j : ddim) â†’ [i â‰¤ j] â†’ A {p i j} :=
            inA p Î± {i j â‡’ fst {b i j}} {i j â‡’ fst {t i j}} in
        [ a i j
        , inB {i j â‡’ [p i j , a i j]} Î± {i j â‡’ snd {b i j}} {i j â‡’ snd {t i j}} i j ]

def sigmaCov (Î“ : type) (A : Î“ â†’ type) (B : (Î³ : Î“) â†’ A Î³ â†’ type)
             (covA : relCov Î“ A) (covB : relCov {(Î³ : Î“) Ã— A Î³} {p â‡’ B {fst p} {snd p}})
             : relCov Î“ {Î³ â‡’ (a : A Î³) Ã— B Î³ a} :=
    i j p Î± b t k â‡’
        let a : (k : ğŸš) â†’ [i â‰¤ k âˆ§ k â‰¤ j] â†’ A {p k} :=
            covA i j p Î± {fst b} {k â‡’ fst {t k}} in
        [ a k
        , covB i j {k â‡’ [p k , a k]} Î± {snd b} {k â‡’ snd {t k}} k ]
-/
/-
   TODO: fix surface syntax to match cof proof terms
         fix refiner to work in type signatures
         fix bug in semantics of Î£-types stopping sigmaInner/sigmaCov -/


/-
def hom (A : type) (a b : A) : type :=
    <|k> â‡’ dext i â‡’ A with [i = d0 â‡’ a | k=d1 â‡’ b]

def pathO (A : ğ•€ â†’ type) (a : A 0) (b : A 1) : type :=
    ext i â‡’ A i with [i = 0 â‡’ a | i = 1 â‡’ b]

def homO (A : ğŸš â†’ type) (a : A d0) (b : A d1) : type :=
    dext i â‡’ A i with [i = d0 â‡’ a | i = d1 â‡’ b]

def Î›â†£Î” (A  : (i j : ğŸš) â†’ [i â‰¤ j] â†’ type)
        (aÎ› : (i j : ğŸš) â†’ [i = d0 âˆ¨ j = d1] â†’ A i j) : type :=
    dext i j [i â‰¤ j] â‡’ A i j with [ i = d0 â‡’ aÎ› d0 j
                                  | j = d1 â‡’ aÎ› i d1 ]

def isInner (A : (i j : ğŸš) â†’ [i â‰¤ j] â†’ type) : type :=
    (b : <|i j [i = d0 âˆ¨ j = d1]> â‡’ A i j)
    â†’ cfill {dext i j [i â‰¤ j] â‡’ A i j with [i = d0 âˆ¨ j = d1 â‡’ b i j]}

def relInner (Î“ : type) (A : Î“ â†’ type) : type :=
    (p : <|i j [i â‰¤ j]> â‡’ Î“)
    â†’ isInner {i j â‡’ {A {p i j}}}

def prodInner (Î“ : type) (A : Î“ â†’ type) (B : Î“ â†’ type)
              (inA : relInner Î“ A) (inB : relInner Î“ B)
              : relInner Î“ {Î³ â‡’ A Î³ Ã— B Î³} :=
    p b Ï† t i j â‡’ [ inA p {i j â‡’ fst {b i j}} Ï† {i j â‡’ fst {t i j}} i j
                  , inB p {i j â‡’ snd {b i j}} Ï† {i j â‡’ snd {t i j}} i j ]

-- #print prodInner


def sigmaInner (Î“ : type) (A : Î“ â†’ type) (B : (Î³ : Î“) â†’ A Î³ â†’ type)
               (inA : relInner Î“ A) (inB : relInner {(Î³ : Î“) Ã— A Î³} {p â‡’ B {fst p} {snd p}})
               : relInner Î“ {Î³ â‡’ (a : A Î³) Ã— B Î³ a} :=
    p b Ï† t i j â‡’
        let a : (i j : ddim) â†’ [i â‰¤ j] â†’ A {p i j} :=
            inA p {i j â‡’ fst {b i j}} Ï† {i j â‡’ fst {t i j}} in
        [ a i j
        , inB {i j â‡’ [p i j , a i j]} {i j â‡’ snd {b i j}} Ï† {i j â‡’ snd {t i j}} i j ]

/-
BAD : i isn't in scope for extension type inside cfill
def isKan (A : ğ•€ â†’ type) : type :=
    <i> â‡’ {(b : A i) â†’ cfill {ext j â‡’ A j with [i=j â‡’ b]}}

def isCov (A : ğŸš â†’ type) : type :=
    <|i> â‡’ {(b : A i) â†’ cfill {dext j [i â‰¤ j] â‡’ A j with [i=j â‡’ b]}}

"def" isFill Phi â†’ (psi â‰¤ phi : ğ”½[Phi]) â†’ (A : Phi â†’ [phi] â†’ type) : type :=
      (b : <cube [psi]> â‡’ A cube)
      â†’ contrFill {cube | [phi] â‡’ A cube with [psi â‡’ b cube]}
-/

def weirdSquare (A : ğ•€ â†’ ğŸš â†’ type)
                (ai0 : (i : ğ•€) â†’ A i d0)
                (ai1 : (i : ğ•€) â†’ A i d1)
                (a0j : dext j â‡’ A 0 j with [ j = d0 â‡’ ai0 0
                                           | j = d1 â‡’ ai1 0 ])
                (a1j : dext j â‡’ A 1 j with [ j = d0 â‡’ ai0 1
                                           | j = d1 â‡’ ai1 1 ]) : type :=
    ext i | j â‡’ A i j with [ j = d0 â‡’ ai0 i
                           | j = d1 â‡’ ai1 i
                           | i = 0  â‡’ a0j j
                           | i = 1  â‡’ a1j j ]


def path (A : type) (a b : A) : type :=
    ext i â‡’ A with [i=0 â‡’ a | i=1 â‡’ b]


def test1 : ddim â†’ nat := x â‡’ 3
def test2 : nat := test1 d1
def test3 (i : ğŸš) : sub nat {i = d0} 3 := test1 i
def test4 (i : ğŸš) : sub nat {i â‰¤ d1} 3 := test1 i
def test5 (i : ğŸš) : sub nat {d0 = d1} [] := test1 i
def test6 (i : ğŸš) : sub nat {d1 â‰¤ d0} [] := test1 i
def test7 : hom nat 3 3 := test1

def test8 (i : ddim) : sub nat {i = d0 âˆ¨ d0 = d1}
                               [ i = d0 â‡’ 3
                               | i = d1 â‡’ 3 ] := test1 i
-/