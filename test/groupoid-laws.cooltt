-- J-like proofs without carrying around J-on-refl paths everywhere
-- (by carrying around cofibrations everywhere instead)

def path (A : type) (x : A) (y : A) : type =
  pathd {_ => A} x y

-- pretend we have CCHM Id-types
def special-j (A : type) (x : A) (B : (Ï† : ğ”½) â†’ {(i : ğ•€) â†’ sub A {i=0 âˆ¨ Ï†} x} â†’ type)
  (d : B #t {_ => x})
  (Ï† : ğ”½) (p : (i : ğ•€) â†’ sub A {i=0 âˆ¨ Ï†} x)
  : sub {B Ï† p} Ï† d
  =
  let filler : ğ•€ â†’ ğ•€ â†’ A =
    j i =>
    hcom A 0 i {âˆ‚ j âˆ¨ Ï†} {i _ =>
      [ i=0 âˆ¨ j=0 âˆ¨ Ï† => p 0
      | j=1 => p i
      ]
    }
  in
  com {j => B {Ï† âˆ¨ j=0} {filler j}} 0 1 {Ï†} {j _ => d}

def trans (A : type) (p : (i : ğ•€) â†’ A)
  : (Ï† : ğ”½) (q : (i : ğ•€) â†’ sub A {i=0 âˆ¨ Ï†} {p 1})
  â†’ sub {path A {p 0} {q 1}} Ï† p
  =
  special-j A {p 1} {_ q => path A {p 0} {q 1}} p

def assoc (A : type)
  (p : (i : ğ•€) â†’ A)
  (Ï† : ğ”½) (q : (i : ğ•€) â†’ sub A {i=0 âˆ¨ Ï†} {p 1})
  : (Ïˆ : ğ”½) (r : (i : ğ•€) â†’ sub A {i=0 âˆ¨ Ïˆ} {q 1})
  â†’ sub {path {path A {p 0} {r 1}} {trans A p {Ï† âˆ§ Ïˆ} {trans A q Ïˆ r}} {trans A {trans A p Ï† q} Ïˆ r}}
    Ïˆ {_ => trans A p Ï† q}
  =
  special-j A {q 1}
    {Ïˆ r => path {path A {p 0} {r 1}} {trans A p {Ï† âˆ§ Ïˆ} {trans A q Ïˆ r}} {trans A {trans A p Ï† q} Ïˆ r}}
    {_ => trans A p Ï† q}

-- get the standard functions by instantiating at #f everywhere

def trans' (A : type) (p : (i : ğ•€) â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1})
  : path A {p 0} {q 1}
  =
  trans A p #f q

def assoc' (A : type)
  (p : (i : ğ•€) â†’ A)
  (q : (i : ğ•€) â†’ sub A {i=0} {p 1})
  (r : (i : ğ•€) â†’ sub A {i=0} {q 1})
  : path {path A {p 0} {r 1}} {trans' A p {trans' A q r}} {trans' A {trans' A p q} r}
  =
  assoc A p #f q #f r
