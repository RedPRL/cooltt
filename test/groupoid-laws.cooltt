-- J-like proofs without carrying around J-on-refl paths everywhere
-- (by carrying around cofibrations everywhere instead)

def path (A : type) (x : A) (y : A) : type =
  pathd {_ => A} x y

-- pretend we have CCHM Id-types
def special-j (A : type) (x : A) (B : (Ï† : ð”½) â†’ {(i : ð•€) â†’ sub A {i=0 âˆ¨ Ï†} x} â†’ type)
  (d : B #t {_ => x})
  (Ï† : ð”½) (p : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ï†} x)
  : sub {B Ï† p} Ï† d
  =
  let filler : ð•€ â†’ ð•€ â†’ A =
    j i =>
    hcom A 0 i {âˆ‚ j âˆ¨ Ï†} {i _ =>
      [ i=0 âˆ¨ j=0 âˆ¨ Ï† => p 0
      | j=1 => p i
      ]
    }
  in
  com {j => B {Ï† âˆ¨ j=0} {filler j}} 0 1 {Ï†} {j _ => d}

def trans (A : type) (p : (i : ð•€) â†’ A)
  : (Ï† : ð”½) (q : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ï†} {p 1})
  â†’ sub {path A {p 0} {q 1}} Ï† p
  =
  special-j A {p 1} {_ q => path A {p 0} {q 1}} p

def assoc (A : type)
  (p : (i : ð•€) â†’ A)
  (Ï† : ð”½) (q : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ï†} {p 1})
  : (Ïˆ : ð”½) (r : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ïˆ} {q 1})
  â†’ sub {path {path A {p 0} {r 1}} {trans A {trans A p Ï† q} Ïˆ r} {trans A p {Ï† âˆ§ Ïˆ} {trans A q Ïˆ r}}}
    Ïˆ {_ => trans A p Ï† q}
  =
  special-j A {q 1}
    {Ïˆ r => path {path A {p 0} {r 1}} {trans A {trans A p Ï† q} Ïˆ r} {trans A p {Ï† âˆ§ Ïˆ} {trans A q Ïˆ r}}}
    {_ => trans A p Ï† q}

def pentagonType (A : type)
  (p : (i : ð•€) â†’ A)
  (Ï† : ð”½) (q : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ï†} {p 1})
  (Ïˆ : ð”½) (r : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ïˆ} {q 1})
  (Ï‡ : ð”½) (s : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ï‡} {r 1})
  : type
  =
  path
    {path
      {path A {p 0} {s 1}}
        {trans A {trans A {trans A p Ï† q} Ïˆ r} Ï‡ s}
        {trans A p {Ï† âˆ§ Ïˆ âˆ§ Ï‡} {trans A q {Ïˆ âˆ§ Ï‡} {trans A r Ï‡ s}}}}
    {trans {path A {p 0} {s 1}}
      {assoc A {trans A p Ï† q} Ïˆ r Ï‡ s}
      {Ïˆ âˆ§ Ï‡}
      {assoc A p Ï† q {Ïˆ âˆ§ Ï‡} {trans A r Ï‡ s}}}
    {trans {path A {p 0} {s 1}}
      {j => trans A {assoc A p Ï† q Ïˆ r j} Ï‡ s}
      {Ï† âˆ§ Ïˆ âˆ§ Ï‡}
      {trans {path A {p 0} {s 1}}
        {assoc A p {Ï† âˆ§ Ïˆ} {trans A q Ïˆ r} Ï‡ s}
        {Ï† âˆ§ Ïˆ âˆ§ Ï‡}
        {j => trans A p {Ï† âˆ§ Ïˆ âˆ§ Ï‡} {assoc A q Ïˆ r Ï‡ s j}}}}

def pentagon (A : type)
  (p : (i : ð•€) â†’ A)
  (Ï† : ð”½) (q : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ï†} {p 1})
  (Ïˆ : ð”½) (r : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ïˆ} {q 1})
  : (Ï‡ : ð”½) (s : (i : ð•€) â†’ sub A {i=0 âˆ¨ Ï‡} {r 1})
  â†’ pentagonType A p Ï† q Ïˆ r Ï‡ s
  =
  special-j A {r 1}
    {pentagonType A p Ï† q Ïˆ r}
    {special-j A {q 1}
      {Ïˆ r => pentagonType A p Ï† q Ïˆ r #t {_ => r 1}}
      {special-j A {p 1}
        {Ï† q => pentagonType A p Ï† q #t {_ => q 1} #t {_ => q 1}}
        {_ _ => p}
        Ï† q}
      Ïˆ r}

-- get the standard functions by instantiating at #f everywhere

def trans' (A : type) (p : (i : ð•€) â†’ A) (q : (i : ð•€) â†’ sub A {i=0} {p 1})
  : path A {p 0} {q 1}
  =
  trans A p #f q

def assoc' (A : type)
  (p : (i : ð•€) â†’ A)
  (q : (i : ð•€) â†’ sub A {i=0} {p 1})
  (r : (i : ð•€) â†’ sub A {i=0} {q 1})
  : path {path A {p 0} {r 1}} {trans' A {trans' A p q} r} {trans' A p {trans' A q r}}
  =
  assoc A p #f q #f r

def pentagon' (A : type)
  (p : (i : ð•€) â†’ A)
  (q : (i : ð•€) â†’ sub A {i=0} {p 1})
  (r : (i : ð•€) â†’ sub A {i=0} {q 1})
  (s : (i : ð•€) â†’ sub A {i=0} {r 1})
  : path
    {path
      {path A {p 0} {s 1}}
        {trans' A {trans' A {trans' A p q} r} s}
        {trans' A p {trans' A q {trans' A r s}}}}
    {trans' {path A {p 0} {s 1}}
      {assoc' A {trans' A p q} r s}
      {assoc' A p q {trans' A r s}}}
    {trans' {path A {p 0} {s 1}}
      {j => trans' A {assoc' A p q r j} s}
      {trans' {path A {p 0} {s 1}}
        {assoc' A p {trans' A q r} s}
        {j => trans' A p {assoc' A q r s j}}}}
  =
  pentagon A p #f q #f r #f s

def test (A : type)
  (p : (i : ð•€) â†’ A)
  (q : (i : ð•€) â†’ sub A {i=0} {p 1})
  (r : (i : ð•€) â†’ sub A {i=0} {q 1})
  (s : (i : ð•€) â†’ sub A {i=0} {r 1})
  : (j : ð•€) â†’ path A {p 0} {r 1}
  =
  j => assoc A p #f q #f r j
