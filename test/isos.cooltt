-- "stdlib"

def path (A : type) (a : A) (b : A) : type :=
  ext i => A with [i=0 => a | i=1 => b]

def trans/filler (A : type) (p : ð•€ â†’ A) (q : (i : ð•€) â†’ sub A {i=0} {p 1}) (j : ð•€) (i : ð•€) : A :=
  hcom A 0 j {âˆ‚ i} {j _ =>
    [ j=0 âˆ¨ i=0 => p i
    | i=1 => q j
    ]
  }

def trans (A : type) (p : ð•€ â†’ A) (q : (i : ð•€) â†’ sub A {i=0} {p 1}) : path A {p 0} {q 1} :=
  trans/filler A p q 1

def unit : type := ext => nat with [#t => 0]

def tt : unit := 0

-- isomorphisms

def iso (A : type) (B : type) : type :=
    (f : A â†’ B)
  Ã— (g : B â†’ A)
  Ã— {(b : B) â†’ path B {f {g b}} b}
  Ã— {(a : A) â†’ path A {g {f a}} a}

def iso/refl (A : type) : iso A A :=
  [     a => a
  , [   a => a
    , [ a i => a
      , a i => a
  ] ] ]

def iso/symm (A : type) (B : type) (I : iso A B) : iso B A :=
  let f := fst I in
  let g := fst {snd I} in
  let Î± := fst {snd {snd I}} in
  let Î² := snd {snd {snd I}} in
  [ g , [ f , [ Î² , Î± ] ] ]

def iso/trans (A : type) (B : type) (C : type) (I1 : iso A B) (I2 : iso B C) : iso A C :=
  let f1 := fst I1 in
  let g1 := fst {snd I1} in
  let Î±1 := fst {snd {snd I1}} in
  let Î²1 := snd {snd {snd I1}} in
  let f2 := fst I2 in
  let g2 := fst {snd I2} in
  let Î±2 := fst {snd {snd I2}} in
  let Î²2 := snd {snd {snd I2}} in
  [a => f2 {f1 a}, 
   [c => g1 {g2 c}, 
    [c => trans C {j => f2 {Î±1 {g2 c} j}} {Î±2 c},
     a => trans A {j => g1 {Î²2 {f1 a} j}} {Î²1 a}]]]

-- pair isos

def iso/pair/comm (A : type) (B : type) : iso {A Ã— B} {B Ã— A} :=
  [ab => [snd ab, fst ab], 
   [ba => [snd ba, fst ba], 
    [ba i => ba, 
     ab i => ab]]]

def iso/pair/assoc (A : type) (B : type) (C : type) : iso {A Ã— B Ã— C} {{A Ã— B} Ã— C} :=
  [a_bc => [[fst a_bc, fst {snd a_bc}], snd {snd a_bc}], 
   [ab_c => [fst {fst ab_c}, [snd {fst ab_c}, snd ab_c]], 
    [ab_c i => ab_c, a_bc i => a_bc]]]

def iso/pair/unit (A : type) : iso {A Ã— unit} A :=
  [au => fst au, 
   [a => [a, tt], 
    [a i => a, 
     au i => au]]]

-- function isos

def curry (A : type) (B : type) (C : type) : {{A Ã— B} â†’ C} â†’ {A â†’ B â†’ C} :=
  f a b => f [a , b]

def uncurry (A : type) (B : type) (C : type) : {A â†’ B â†’ C} â†’ {{A Ã— B} â†’ C} :=
  f ab => f {fst ab} {snd ab}

def iso/curry (A : type) (B : type) (C : type) : iso {A â†’ B â†’ C} {{A Ã— B} â†’ C} :=
  [uncurry A B C, 
   [curry A B C, 
    [ab_c i => ab_c,
     a_b_c i => a_b_c]]]

def iso/lhs (A : type) (B : type) (C : type) (I : iso A B) : iso {A â†’ C} {B â†’ C} :=
  let f := fst I in
  let g := fst {snd I} in
  let Î± := fst {snd {snd I}} in
  let Î² := snd {snd {snd I}} in
  [ac b => ac {g b}, 
   [bc a => bc {f a}, 
    [bc i b => bc {Î± b i}, 
     ac i a => ac {Î² a i}]]]

def iso/lhs (A : type) (B : type) (C : type) (I : iso A B) : iso {C â†’ A} {C â†’ B} :=
  let f := fst I in
  let g := fst {snd I} in
  let Î± := fst {snd {snd I}} in
  let Î² := snd {snd {snd I}} in
  [ca c => f {ca c}, 
   [cb c => g {cb c}, 
    [cb i c => Î± {cb c} i, 
     ca i c => Î² {ca c} i]]]

def iso/flip (A : type) (B : type) (C : type) : iso {A â†’ B â†’ C} {B â†’ A â†’ C} :=
  [abc b a => abc a b, 
   [bac a b => bac b a,
    [bac i => bac,
     abc i => abc]]]
