def mycoe/fun : {
  (A : (i : 𝕀) → type) (B : (i: 𝕀) → type)
  (coe/A : (r : 𝕀) (x : A r) (i : 𝕀) → sub {A i} {i=r} x)
  (coe/B : (r : 𝕀) (x : B r) (i : 𝕀) → sub {B i} {i=r} x)
  (r : 𝕀) (f : (_ : A r) → B r) (i : 𝕀) →
  sub {(_ : A i) → B i} {i=r} f
} = {
 A B coe/A coe/B r f i x =>
 coe/B r {f {coe/A i x r}} i
}

def mycom/fun : {
  (A : 𝕀 → type)
  (B : 𝕀 → type)
  (com/A : (r : 𝕀) (φ : 𝔽) (p : (i : 𝕀) (_ : [i=r ∨ φ]) → A i) (i : 𝕀) → sub {A i} {i=r ∨ φ} {p i _})
  (com/B : (r : 𝕀) (φ : 𝔽) (p : (i : 𝕀) (_ : [i=r ∨ φ]) → B i) (i : 𝕀) → sub {B i} {i=r ∨ φ} {p i _})
  (r : 𝕀) (φ : 𝔽) (p : (i : 𝕀) (_ : [i=r ∨ φ]) (_ : A i) → B i) (i : 𝕀) → sub {(_ : A i) → B i} {i=r ∨ φ} {p i _}
} = {
  A B com/A com/B r φ p r' x =>
  com/B r φ {j _ => p j _ {com/A r' #f {_ _ => x} j}} r'
}

normalize mycom/fun

def coe/intro : {
  (A : 𝕀 → type) (r : 𝕀) (r' : 𝕀) (x : A r) →
  sub {A r'} {r=r'} x
} = {
 A r r' x => coe A r r' x
}

def coe/pi : {
  (A : 𝕀 → type) (B : (i : 𝕀) → A i → type)
  (r : 𝕀) (r' : 𝕀)
  (f : (x : A r) → B r x) →
  sub {(x : A r') → B r' x} #t {x => coe {i => B i {coe A r' i x}} r r' {f {coe A r' r x}}}
} = {
 A B r r' f =>
 coe {i => (x : A i) → B i x} r r' f
}

normalize coe/pi

def coe/sigma : {
  (A : 𝕀 → type) (B : (i : 𝕀) → A i → type)
  (r : 𝕀) (r' : 𝕀)
  (p : (x : A r) × B r x) →
  sub {(x : A r') × B r' x} #t [coe A r r' {fst p}, coe {i => B i {coe A r i {fst p}}} r r' {snd p}]
} = {
  A B r r' p =>
  coe {i => (x : A i) × B i x} r r' p
}

normalize coe/sigma

def coe/pathd : {
  (A : 𝕀 -> 𝕀 -> type)
  (r : 𝕀)
  (r' : 𝕀)
  (a : (i : 𝕀) -> A i 0)
  (b : (i : 𝕀) -> A i 1)
  (m : pathd {A r} {a r} {b r})
  -> sub {pathd {A r'} {a r'} {b r'}} #t
     {j =>
       com {i => A i j} r r' {∂ j}
         {i p => [j=0 => a i | j=1 => b i | i=r => m j]}}
} = {
  A r r' a b m =>
  coe {i => pathd {A i} {a i} {b i}} r r' m
}

normalize coe/pathd

def hcom/intro : {
  (A : type) (r : 𝕀) (r' : 𝕀) (φ : 𝔽)
  (p : (i : 𝕀) (_ : [i=r ∨ φ]) → A) →
  sub A {r=r' ∨ φ} {p r' _}
} = {
  A r r' φ p =>
  hcom A r r' φ p
}

def hcom/fun : {
  (A : type) (B : type) (r : 𝕀) (r' : 𝕀) (φ : 𝔽)
  (p : (i : 𝕀) (_ : [i=r ∨ φ]) → A → B) →
  sub {A → B} #t {x => hcom B r r' φ {j _ => p j _ x}}
} = {
  A B r r' φ p =>
  hcom {A → B} r r' φ p
}

normalize hcom/fun

def com/intro : {
  (A : 𝕀 → type) (r : 𝕀) (r' : 𝕀) (φ : 𝔽)
  (p : (i : 𝕀) (_ : [i=r ∨ φ]) → A i) →
  sub {A r'} {r=r' ∨ φ} {p r' _}
} = {
  A r r' φ p =>
  com A r r' φ p
}

normalize com/intro

def com/decomposition : {
  (A : 𝕀 → type) (r : 𝕀) (r' : 𝕀) (φ : 𝔽)
  (p : (i : 𝕀) (_ : [i=r ∨ φ]) → A i) →
  sub {A r'} #t {hcom {A r'} r r' φ {j _ => coe A j r' {p j _}}}
} = {
  A r r' φ p =>
  com A r r' φ p
}
