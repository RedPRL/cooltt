def path (A : type) (a : A) (b : A) : type :=
  ext i => A with [i=0 => a | i=1 => b]

def is-contr (C : type) : type :=
  (c : C) Ã— {(c' : C) â†’ path C c c'}

def is-prop (C : type) : type :=
  (c : C) (c' : C) â†’ path C c c'

def has-hlevel : nat â†’ type â†’ type :=
  let aux : nat â†’ type â†’ type :=
    elim [
    | zero => is-prop
    | suc {l => ih} =>
      A => (a : A) (a' : A) â†’ ih {path A a a'}
    ]
  in
  elim [
  | zero => is-contr
  | suc l => aux l
  ]

def is-set : type â†’ type := has-hlevel 2
def is-groupoid : type â†’ type := has-hlevel 3

def hLevel (n : nat) : type :=
  (A : type) Ã— has-hlevel n A

def hProp : type := hLevel 1
def hSet : type := hLevel 2
def hGroupoid : type := hLevel 3

print hProp
normalize hProp

def symm/filler (A : type) (p : ğ•€ â†’ A) (i : ğ•€) : ğ•€ â†’ A :=
  hfill A 0 {âˆ‚ i} {j _ =>
    [ j=0 âˆ¨ i=1 => p 0
    | i=0 => p j
    ]
  }

def symm (A : type) (p : ğ•€ â†’ A) : path A {p 1} {p 0} :=
  i => symm/filler A p i 1

def trans/filler (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) (j : ğ•€) (i : ğ•€) : A :=
  hcom A 0 j {âˆ‚ i} {j _ =>
    [ j=0 âˆ¨ i=0 => p i
    | i=1 => q j
    ]
  }

def trans (A : type) (p : ğ•€ â†’ A) (q : (i : ğ•€) â†’ sub A {i=0} {p 1}) : path A {p 0} {q 1} :=
  trans/filler A p q 1

def contr-prop (A : type) (A/contr : is-contr A) : is-prop A :=
  a a' => trans A {symm A {{snd A/contr} a}} {{snd A/contr} a'}

def prop-set (A : type) (A/prop : is-prop A) : is-set A :=
  a b p q i j => hcom A 0 1 {âˆ‚ i âˆ¨ âˆ‚ j} {k _ =>
    [ k=0 âˆ¨ âˆ‚ j âˆ¨ i=0 => A/prop a {p j} k
    | i=1 => A/prop a {q j} k
    ]
  }

def raise-hlevel : (l : nat) (A : type) â†’ has-hlevel l A â†’ has-hlevel {suc l} A :=
  let aux : (m : nat) â†’ (B : type) â†’ has-hlevel {suc m} B â†’ has-hlevel {suc {suc m}} B :=
    elim [
    | zero => prop-set
    | suc {l => ih} => B B/lvl b b' => ih {path B b b'} {B/lvl b b'}
    ]
  in
  elim [
  | zero => contr-prop
  | suc l => aux l
  ]

def prop-hlevel : (l : nat) (A : type) â†’ is-prop A â†’ has-hlevel {suc l} A :=
  elim [
  | zero => _ A/prop => A/prop
  | suc {l => ih} => A A/prop => raise-hlevel {suc l} A {ih A A/prop}
  ]

def path-hlevel 
  : (l : nat) (A : type) (A/level : has-hlevel {suc l} A) (a : A) (a' : A)
  â†’ has-hlevel l {path A a a'} 
  :=
  elim [
  | zero => A A/prop a a' => [A/prop a a', p => prop-set A A/prop a a' {A/prop a a'} p]
  | suc l => A A/lvl a a' => A/lvl a a'
  ]

def path-based-contr (A : type) (a : A) : is-contr {(x : A) Ã— path A a x} :=
  [ [a, i => a]
  , x i =>
    let aux : ğ•€ â†’ A := j =>
      hcom A 0 j {âˆ‚ i} {k _ =>
        [ k=0 âˆ¨ i=0 => a
        | i=1 => {snd x} k
        ]
      }
    in
    [aux 1, aux]
  ]
