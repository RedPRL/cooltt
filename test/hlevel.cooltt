import prelude


abstract
def has-hlevel : nat â†’ type â†’ type :=
  let aux : nat â†’ type â†’ type :=
    elim [
    | zero => A => (a a' : A) â†’ path A a a'
    | suc {l => ih} =>
      A => (a : A) (a' : A) â†’ ih {path A a a'}
    ]
  in
  elim [
    | zero => A => sig [pt : A, path : (pt' : A) â†’ path A pt pt']
    | suc l => A => aux l A
  ]

def htype : type :=
  sig
    def lvl : nat
    def tp : type
    def prf : has-hlevel lvl tp
  end

def contr : type :=  htype # [lvl := 0]
def prop : type := htype # [lvl := 1]
def set : type := htype # [lvl := 2]
def groupoid : type := htype # [lvl := 3]

#print prop
#normalize prop

abstract
def contr-prop (A : contr) : prop # [tp := A.tp] := 
  open A in
  struct
    def prf := unfold has-hlevel in pt pt' => trans tp {symm tp {prf.path pt}} {prf.path pt'}
  end 

abstract
def prop-set (A : prop) : set # [tp := A.tp] :=
  open A in
  struct
    def prf := unfold has-hlevel in a b p q i j => 
      hcom tp 0 1 {âˆ‚ i âˆ¨ âˆ‚ j} {k =>
        [ k=0 âˆ¨ âˆ‚ j âˆ¨ i=0 => prf a {p j} k
        | i=1 => prf a {q j} k
        ]
      }
  end

abstract
def raise-hlevel (A : htype) : htype # [lvl := suc {A.lvl}, tp := A.tp] :=
  let aux : (m : nat) (B : htype # [lvl := suc m]) â†’ htype # [lvl := suc {suc m}, tp := B.tp] :=
    elim [
    | zero => prop-set
    | suc {l => ih} => B => 
      unfold has-hlevel in 
      struct 
        def prf := b b' => {ih {struct [tp := path {B.tp} b b', prf := B.prf b b']}}.prf
      end
    ]
  in
  let aux2 : (m : nat) (B : htype # [lvl := m]) â†’ htype # [lvl := suc m, tp := B.tp] :=
    elim [
    | zero => contr-prop
    | suc l => aux l
    ]
  in
  aux2 {A.lvl} A

abstract
def prop-hlevel : (l : nat) (A : prop) â†’ htype # [lvl := suc l, tp := A.tp] :=
  elim [
  | zero => A => A
  | suc {l => ih} => A => raise-hlevel {ih A}
  ]

abstract
def path-hlevel : (l : nat) (A : htype # [lvl := suc l]) (a a' : A.tp) â†’ htype # [lvl := l, tp := path {A.tp} a a'] :=
  elim [
  | zero => A a a' => 
    unfold has-hlevel in 
    struct 
      def prf := struct [pt := A.prf a a', path := {prop-set A}.prf a a' {A.prf a a'}]
    end
  | suc l => 
    unfold has-hlevel in
    A a a' => struct [prf := {A.prf} a a']
  ]

abstract
def path-based-contr (A : type) (a : A) : contr # [tp := (x : A) Ã— path A a x] :=
  struct
    def prf := 
      unfold has-hlevel in
      struct
        def pt := [a, i => a]
        def path := x i =>
         let aux : ğ•€ â†’ A := j =>
            hcom A 0 j {âˆ‚ i} {k =>
              [ k=0 âˆ¨ i=0 => a
              | i=1 => {snd x} k
              ]
            }
          in
          [aux 1, aux]
      end 
  end