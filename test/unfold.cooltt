import prelude
import hlevel

/-
  In this file, we demonstrate some examples of low-level declarations that a
  high-level interface for conditional opacity and unfolding could be
  elaborated to.
-/

/-
  abstract def + : nat → nat → nat :=
    elim [
    | zero => n => n
    | suc {_ => ih} => n => suc {ih n}
    ]
-/

axiom +∷unf : 𝕀
def +∷def (_ : [+∷unf=1]) : nat → nat → nat :=
  elim [
  | zero => n => n
  | suc {_ => ih} => n => suc {ih n}
  ]

axiom + : sub {nat → nat → nat} {+∷unf=1} {+∷def _}

#normalize +

/-
  abstract def +R : (x : nat) → path nat {+ x 0} x :=
    unfolding + in
    elim [
    | zero =>
      _ => 0
    | suc {y => ih} =>
      i => suc {ih i}
    ]
-/

axiom +R∷unf : 𝕀
axiom +R∷unf∷+ : [+R∷unf ≤ +∷unf]

def +R∷def (_ : [+R∷unf=1]) : (x : nat) → path nat {+ x 0} x :=
  elim [
  | zero =>
    _ => 0
  | suc {y => ih} =>
    i => suc {ih i}
  ]

axiom +R : sub {(x : nat) → path nat {+ x 0} x} {+R∷unf=1} {+R∷def _}

#normalize +


def +R-unfolded (_ : [+R∷unf=1]) : (x : nat) → path nat {+ x 0} x := +R
#normalize +R-unfolded


-- next we demonstrate unfolding in the *types* of declarations

/-

  abstract def two : nat := 2

  abstract def foo : unfolding two in (p : path nat 2 two) → path {path nat 2 two} p {_ => 2} :=
    p =>
    nat∷is-set 2 2 p {_ => 2}
-/

axiom two∷unf : 𝕀
axiom two : sub nat {two∷unf=1} {2}

axiom foo∷unf∷tm : 𝕀

axiom foo∷unf∷tp : 𝕀
axiom foo∷unf∷tp∷two : [foo∷unf∷tp ≤ two∷unf]
axiom foo∷unf∷tm∷tp : [foo∷unf∷tm ≤ foo∷unf∷tp]

def foo∷tp (_ : [foo∷unf∷tp=1]) : type :=
  (p : path nat 2 two)
  → path {path nat 2 two} p {_ => 2}

axiom nat∷is-set : is-set nat

def foo∷def (_ : [foo∷unf∷tm=1]) : foo∷tp _ :=
  p =>
  nat∷is-set 2 2 p {_ => 2}


/-

 The idea is currently that the type part and the term part of a declaration
 can be preceeded by a single "unfolding" clause each. Whatever is unfolded in
 the type is by necessity also unfolded in the term.

-/
