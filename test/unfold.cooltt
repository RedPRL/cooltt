import prelude
import hlevel

/-
  In this file, we demonstrate some examples of low-level declarations that a
  high-level interface for conditional opacity and unfolding could be
  elaborated to.
-/

/-
  abstract def + : nat â†’ nat â†’ nat :=
    elim [
    | zero => n => n
    | suc {_ => ih} => n => suc {ih n}
    ]
-/

axiom +âˆ·unf : ð•€
def +âˆ·def (_ : [+âˆ·unf=1]) : nat â†’ nat â†’ nat :=
  elim [
  | zero => n => n
  | suc {_ => ih} => n => suc {ih n}
  ]

axiom + : sub {nat â†’ nat â†’ nat} {+âˆ·unf=1} {+âˆ·def _}

#normalize +

/-
  unfolding + in
  abstract def +R : (x : nat) â†’ path nat {+ x 0} x :=
    elim [
    | zero =>
      _ => 0
    | suc {y => ih} =>
      i => suc {ih i}
    ]
-/

axiom +Râˆ·unf : ð•€
axiom +Râˆ·unfâˆ·+ : [+Râˆ·unf â‰¤ +âˆ·unf]

def +Râˆ·def (_ : [+Râˆ·unf=1]) : (x : nat) â†’ path nat {+ x 0} x :=
  elim [
  | zero =>
    _ => 0
  | suc {y => ih} =>
    i => suc {ih i}
  ]

axiom +R : sub {(x : nat) â†’ path nat {+ x 0} x} {+Râˆ·unf=1} {+Râˆ·def _}

#normalize +R


def +R-unfolded (_ : [+Râˆ·unf=1]) : (x : nat) â†’ path nat {+ x 0} x := +R
#normalize +R-unfolded


-- next we demonstrate unfolding in the *types* of declarations, which we call "requiring"

/-

  abstract def two : nat := 2

  requiring two in
  abstract def foo : (p : path nat 2 two) â†’ path {path nat 2 two} p {_ => 2} :=
    p =>
    natâˆ·is-set 2 2 p {_ => 2}
-/

axiom twoâˆ·unf : ð•€
axiom two : sub nat {twoâˆ·unf=1} {2}

axiom fooâˆ·unf : ð•€
axiom fooâˆ·unfâˆ·tpâˆ·two : [fooâˆ·unf â‰¤ twoâˆ·unf]

def fooâˆ·tp (_ : [twoâˆ·unf=1]) : type :=
  (p : path nat 2 two)
  â†’ path {path nat 2 two} p {_ => 2}

axiom natâˆ·is-set : is-set nat

def fooâˆ·def (_ : [fooâˆ·unf=1]) : fooâˆ·tp _ :=
  p =>
  natâˆ·is-set 2 2 p {_ => 2}

