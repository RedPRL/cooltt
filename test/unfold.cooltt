import prelude
import hlevel

/-
  In this file, we demonstrate some examples of low-level declarations that a
  high-level interface for conditional opacity and unfolding could be
  elaborated to.
-/

/-
  abstract def + : nat → nat → nat :=
    elim [
    | zero => n => n
    | suc {_ => ih} => n => suc {ih n}
    ]
-/

axiom +∷unf : 𝕀
def +∷def (_ : [+∷unf=1]) : nat → nat → nat :=
  elim [
  | zero => n => n
  | suc {_ => ih} => n => suc {ih n}
  ]

axiom + : sub {nat → nat → nat} {+∷unf=1} {+∷def _}

#normalize +

/-
  unfolding + in
  abstract def +R : (x : nat) → path nat {+ x 0} x :=
    elim [
    | zero =>
      _ => 0
    | suc {y => ih} =>
      i => suc {ih i}
    ]
-/

axiom +R∷unf : 𝕀
axiom +R∷unf∷+ : [+R∷unf ≤ +∷unf]

def +R∷def (_ : [+R∷unf=1]) : (x : nat) → path nat {+ x 0} x :=
  elim [
  | zero =>
    _ => 0
  | suc {y => ih} =>
    i => suc {ih i}
  ]

axiom +R : sub {(x : nat) → path nat {+ x 0} x} {+R∷unf=1} {+R∷def _}

#normalize +R


def +R-unfolded (_ : [+R∷unf=1]) : (x : nat) → path nat {+ x 0} x := +R
#normalize +R-unfolded


-- next we demonstrate unfolding in the *types* of declarations, which we call "requiring"

/-

  abstract def two : nat := 2

  requiring two in
  abstract def foo : (p : path nat 2 two) → path {path nat 2 two} p {_ => 2} :=
    p =>
    nat∷is-set 2 2 p {_ => 2}
-/

axiom two∷unf : 𝕀
axiom two : sub nat {two∷unf=1} {2}

axiom foo∷unf : 𝕀
axiom foo∷unf∷tp∷two : [foo∷unf ≤ two∷unf]

def foo∷tp (_ : [two∷unf=1]) : type :=
  (p : path nat 2 two)
  → path {path nat 2 two} p {_ => 2}

axiom nat∷is-set : is-set nat

def foo∷def (_ : [foo∷unf=1]) : foo∷tp _ :=
  p =>
  nat∷is-set 2 2 p {_ => 2}

