<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CofThy (cooltt.Cubical__.CofThy)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">cooltt</a> &#x00BB; <a href="../index.html">Cubical__</a> &#x00BB; CofThy</nav><h1>Module <code>Cubical__.CofThy</code></h1></header><div class="spec module" id="module-ConsistencyMonad"><a href="#module-ConsistencyMonad" class="anchor"></a><code><span class="keyword">module</span> <a href="ConsistencyMonad/index.html">ConsistencyMonad</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-ConsistencyMonadUtil"><a href="#module-ConsistencyMonadUtil" class="anchor"></a><code><span class="keyword">module</span> <a href="ConsistencyMonadUtil/index.html">ConsistencyMonadUtil</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-CofVar"><a href="#module-CofVar" class="anchor"></a><code><span class="keyword">module</span> <a href="CofVar/index.html">CofVar</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-cof"><a href="#type-cof" class="anchor"></a><code><span class="keyword">type</span> cof</code><code> = <span><span>(<a href="../../Cubical/Dim/index.html#type-dim">Cubical.Dim.dim</a>, <a href="CofVar/index.html#type-t">CofVar.t</a>)</span> <a href="../../Cubical/Cof/index.html#type-cof">Cubical.Cof.cof</a></span></code></dt></dl><div class="spec module" id="module-UF"><a href="#module-UF" class="anchor"></a><code><span class="keyword">module</span> <a href="UF/index.html">UF</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Assignment"><a href="#module-Assignment" class="anchor"></a><code><span class="keyword">module</span> <a href="Assignment/index.html">Assignment</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-alg_thy'"><a href="#type-alg_thy'" class="anchor"></a><code><span class="keyword">type</span> alg_thy'</code><code> = </code><code>{</code><table class="record"><tr id="type-alg_thy'.classes" class="anchored"><td class="def field"><a href="#type-alg_thy'.classes" class="anchor"></a><code>classes : <a href="UF/index.html#type-t">UF.t</a>;</code></td><td class="doc"><p>equivalence classes of dimensions</p></td></tr><tr id="type-alg_thy'.known_vars" class="anchored"><td class="def field"><a href="#type-alg_thy'.known_vars" class="anchor"></a><code>known_vars : <a href="Assignment/index.html#type-t">Assignment.t</a>;</code></td></tr></table><code>}</code></dt><dd><p>A presentation of an algebraic theory over the language of intervals and cofibrations.</p></dd></dl><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">type</span> var</code><code> = <a href="CofVar/index.html#type-t">CofVar.t</a> * bool</code></dt><dt class="spec type" id="type-eq"><a href="#type-eq" class="anchor"></a><code><span class="keyword">type</span> eq</code><code> = <a href="../../Cubical/Dim/index.html#type-dim">Cubical.Dim.dim</a> * <a href="../../Cubical/Dim/index.html#type-dim">Cubical.Dim.dim</a></code></dt></dl><dl><dt class="spec value" id="val-neg_eq"><a href="#val-neg_eq" class="anchor"></a><code><span class="keyword">val</span> neg_eq : <a href="../../Cubical/Dim/index.html#type-dim">Cubical.Dim.dim</a> <span>&#45;&gt;</span> <a href="../../Cubical/Dim/index.html#type-dim">Cubical.Dim.dim</a> <span>&#45;&gt;</span> <span><span>(<a href="../../Cubical/Dim/index.html#type-dim">Cubical.Dim.dim</a>, <span class="type-var">'a</span>)</span> <a href="../../Cubical/Cof/index.html#type-cof">Cubical.Cof.cof</a></span></code></dt></dl><dl><dt class="spec type" id="type-branch"><a href="#type-branch" class="anchor"></a><code><span class="keyword">type</span> branch</code><code> = <span><a href="index.html#type-var">var</a> list</span> * <span><a href="index.html#type-eq">eq</a> list</span></code></dt><dd><p>A <code>branch</code> represents the meet of a bunch of atomic cofibrations.</p></dd></dl><dl><dt class="spec type" id="type-branches"><a href="#type-branches" class="anchor"></a><code><span class="keyword">type</span> branches</code><code> = <span><a href="index.html#type-branch">branch</a> list</span></code></dt><dt class="spec type" id="type-cached_branch"><a href="#type-cached_branch" class="anchor"></a><code><span class="keyword">type</span> cached_branch</code><code> = <a href="index.html#type-alg_thy'">alg_thy'</a> * <span>(<a href="Assignment/index.html#type-t">Assignment.t</a> * <span><a href="index.html#type-eq">eq</a> list</span>)</span></code></dt><dd><p>A <code>cached_branch</code> is a <code>branch</code> together with an algebraic theory * representing the resulting theory at the end of the branch.</p></dd></dl><dl><dt class="spec type" id="type-cached_branches"><a href="#type-cached_branches" class="anchor"></a><code><span class="keyword">type</span> cached_branches</code><code> = <span><a href="index.html#type-cached_branch">cached_branch</a> list</span></code></dt><dt class="spec type" id="type-alg_thy"><a href="#type-alg_thy" class="anchor"></a><code><span class="keyword">type</span> alg_thy</code><code> = <span><a href="index.html#type-alg_thy'">alg_thy'</a> <a href="ConsistencyMonad/index.html#type-m">ConsistencyMonad.m</a></span></code></dt><dd><p>As an optimization, we remember when a theory is consistent or not.</p></dd></dl><dl><dt class="spec type" id="type-disj_thy"><a href="#type-disj_thy" class="anchor"></a><code><span class="keyword">type</span> disj_thy</code><code> = <a href="index.html#type-cached_branches">cached_branches</a></code></dt><dd><p>A disjoint theory is the join of a list of <code>cached_branch</code>. We do not need to * remember the common ancestor of these branches (as an algebraic theory), but only * the atomic cofibrations labeling the path from the common ancestor to each branch.</p></dd></dl><dl><dt class="spec value" id="val-dissect_cofibrations"><a href="#val-dissect_cofibrations" class="anchor"></a><code><span class="keyword">val</span> dissect_cofibrations : <span><a href="index.html#type-cof">cof</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-branches">branches</a></code></dt><dd><p>This is to dissect the meet of a list of cofibrations into a list of branches. * * Possible further optimizations: * 1. Should we use <code>Cof.reduce</code> to massage the cofibrations first? * 2. Should we eagerly factor out common cofibrations to facilitate the refactoring * steps later on? (This does not seem to be helpful in preliminary experiments.)</p></dd></dl><div class="spec module" id="module-Alg"><a href="#module-Alg" class="anchor"></a><code><span class="keyword">module</span> <a href="Alg/index.html">Alg</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Disj"><a href="#module-Disj" class="anchor"></a><code><span class="keyword">module</span> <a href="Disj/index.html">Disj</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>